import Mathlib.RingTheory.Valuation.ValuationRing
import Mathlib.RingTheory.DiscreteValuationRing.Basic
import Mathlib.Topology.UniformSpace.Cauchy
import Mathlib.Topology.Algebra.Ring.Basic
import Mathlib.Topology.Order.Basic
import Mathlib.Topology.Algebra.Valuation
import Mathlib.Algebra.Order.Hom.Monoid
import Mathlib.Algebra.Order.Group.TypeTags
/-!
# Missing Pieces of Mathlib

In this file, we collect missing theorems, instances as prequisite of this project. Theorems in this file should be added to mathlib file scatterly into each file.
-/
set_option autoImplicit false

section ValuationTopology
variable (R: Type*)
-- variable {Œì‚ÇÄ : Type*} [LinearOrderedCommMonoidWithZero Œì‚ÇÄ]

namespace ValuationRingTopology
variable [CommRing R] [IsDomain R] [ValuationRing R]

/-- The preorder of divisibility associated to a valuation ring, i.e. `a ‚â§ b` if there exist `c`, such that `a * c = b`. -/
scoped instance : Preorder R where
 le a b := ‚àÉ c, a * c = b
 le_refl _ := ‚ü®1, mul_one _‚ü©
 le_trans _ _ _ := fun ‚ü®u, h‚ü© ‚ü®v, g‚ü© => ‚ü®u * v, by rw [‚Üê g, ‚Üê h]; ring‚ü©

-- /-- The topology on a valuation ring `R` is defined to be the topology associated to the preorder of divisibility.-/
-- scoped instance : TopologicalSpace R := Preorder.topology R

-- scoped instance : OrderTopology R := ‚ü®rfl‚ü©

-- scoped instance : UniformSpace R where
--   uniformity := sorry
--   refl := sorry
--   symm := sorry
--   comp := sorry
--   isOpen_uniformity := sorry


/-!
-- the following is missed in `Mathlib.RingTheory.Valuation.ValuationRing`

def ValuationRing.setoid : Setoid R where
  r a b := a ‚â§ b ‚àß b ‚â§ a
  -- 2 elements is equiv if both a ‚â§ b and b ‚â§ a
  iseqv := sorry


def ValuationRing.ValueMonoid := Quotient (ValuationRing.setoid R) -- this is really a monoid with zero

instance : LinearOrderedCommMonoidWithZero (ValuationRing.ValueMonoid R) := sorry

scoped instance : Valued R (ValuationRing.ValueMonoid R) := _

-- `Valued` uses Group instead of Monoid... `Maybe the correct way is to generalize mathlib's valued to monoid instead of group???`
-/

scoped instance : Valued R (ValuationRing.ValueGroup R (FractionRing R)) := sorry

scoped instance : OrderTopology R where
  topology_eq_generate_intervals := sorry

-- the topology not rfl to
scoped instance : TopologicalRing R := sorry



end ValuationRingTopology


-- open ValuationTopology
-- variable [CommRing R] [IsDomain R] [ValuationRing R]
-- #synth TopologicalRing R

end ValuationTopology

section ValuationIdeal

#check Valuation.integer

notation:max " ùí™[" v:max "] " => Valuation.integer v

-- Mathlib.RingTheory.Valuation.Integers
def Valuation.LEIdeal {R : Type*}  {Œì‚ÇÄ : Type*}  [Ring R] [LinearOrderedCommGroupWithZero Œì‚ÇÄ]  (v : Valuation R Œì‚ÇÄ) (Œ≥ : Œì‚ÇÄ) : Ideal (Valuation.integer v) := sorry
-- when gamma < 1, the ideal is whole ring

def Valuation.LTIdeal {R : Type*}  {Œì‚ÇÄ : Type*}  [Ring R] [LinearOrderedCommGroupWithZero Œì‚ÇÄ]  (v : Valuation R Œì‚ÇÄ) (Œ≥ : Œì‚ÇÄ) : Ideal (Valuation.integer v) := sorry
-- when gamma < 1, the ideal is whole ring

def Valuation.maximalIdeal {R : Type*}  {Œì‚ÇÄ : Type*}  [Ring R] [LinearOrderedCommGroupWithZero Œì‚ÇÄ]  (v : Valuation R Œì‚ÇÄ) : Ideal (Valuation.integer v) := Valuation.LTIdeal v 1 -- def use either localring.maximalideal or v < 1, then show the remaining one as theorem when K is a field

notation:max " ùìÇ[" v:max "] " => Valuation.maximalIdeal v

-- `In Discrete Valuation Ring, relation between LT LE Ideal`

variable {R : Type*}  {Œì‚ÇÄ : Type*}  [CommRing R] [LinearOrderedCommGroupWithZero Œì‚ÇÄ]  (v : Valuation R Œì‚ÇÄ)

-- may need field
instance : (Valuation.maximalIdeal v).IsMaximal := sorry

end ValuationIdeal

section ValuationInteger
variable {K L : Type*} [Field K] [Field L] {ŒìK ŒìL : Type*} [LinearOrderedCommGroupWithZero ŒìK][LinearOrderedCommGroupWithZero ŒìL] [Algebra K L] {vK : Valuation K ŒìK} {vL : Valuation L ŒìL}

instance : ValuationRing vK.integer where
  cond' := sorry

-- `the maximal ideal = the lt ideal`

notation:max " ùìÄ[" v:max "] " => LocalRing.ResidueField ‚Ü•ùí™[v]

#check ùìÄ[vK]
-- `instance, when ùìÄ[vK] is a field`


-- `Key theorem, OL/OK is generated by 1 element`

end ValuationInteger

-- `Instance of trivial group Unit being LinearOrderedCommGroupWithZero`

section QuotientAlgebra

variable {R S : Type*} [CommRing R] [CommRing S] {I : Ideal R} {J : Ideal S} [Algebra R S]

def Ideal.quotientAlgebra' (h : I ‚â§ RingHom.ker (algebraMap R S)) : Algebra (R‚ß∏I) S := (Ideal.Quotient.lift _ _ h).toAlgebra

-- Maybe we should just keep this ignored
instance [h : Fact (I ‚â§ RingHom.ker (algebraMap R S))] : Algebra (R‚ß∏I) S := Ideal.quotientAlgebra' h.out

-- variable {S‚ÇÅ S‚ÇÇ : Type*} [CommRing S‚ÇÅ] [CommRing S‚ÇÇ] [Algebra R S‚ÇÅ] [Algebra R S‚ÇÇ] {I : Ideal R} {J‚ÇÅ : Ideal S‚ÇÅ} {J‚ÇÇ : Ideal S‚ÇÇ}

-- def AlgHom.Quotient‚ÇÇ (s : S‚ÇÅ ‚Üí‚Çê[R] S‚ÇÇ) (h : J‚ÇÅ ‚â§ J‚ÇÇ.comap s) : S‚ÇÅ‚ß∏J‚ÇÅ ‚Üí‚Çê[R] S‚ÇÇ‚ß∏J‚ÇÇ := Ideal.quotientMap‚Çê _ s h

#check Ideal.quotientMap‚Çê




end QuotientAlgebra
